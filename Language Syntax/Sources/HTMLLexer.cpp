/*
* This file is part of Wakanda software, licensed by 4D under
*  (i) the GNU General Public License version 3 (GNU GPL v3), or
*  (ii) the Affero General Public License version 3 (AGPL v3) or
*  (iii) a commercial license.
* This file remains the exclusive property of 4D and/or its licensors
* and is protected by national and international legislations.
* In any event, Licensee's compliance with the terms and conditions
* of the applicable license constitutes a prerequisite to any use of this file.
* Except as otherwise expressly stated in the applicable license,
* such license does not include any other license or rights on this file,
* 4D's and/or its licensors' trademarks and/or other proprietary rights.
* Consequently, no title, copyright or other proprietary rights
* other than those specified in the applicable license is granted.
*/
#include "LanguageSyntaxHeaders.h"

#include "HTMLLexer.h"

class HTMLLexerToken : public ILexerToken
{
	public :
		HTMLLexerToken ( ILexerToken::TYPE inType, VIndex inPosition, VIndex inLength, VString inText = "", int inValue = -1) :
													m_nType ( inType ), m_nPosition ( inPosition ), m_nLength ( inLength ),
													m_nTokenValue( inValue ), m_vstrText( inText )
													{ ; }
		virtual ~HTMLLexerToken ( ) { ; }

		virtual ILexerToken::TYPE GetType ( ) { return m_nType; }
		virtual XBOX::VIndex GetPosition ( ) { return m_nPosition; }
		virtual XBOX::VIndex GetLength ( ) { return m_nLength; }
		virtual VString GetText( ) { return m_vstrText; }
		virtual int GetValue( ) { return m_nTokenValue; }

		virtual void SelfDelete() { delete this; }

	private :

		ILexerToken::TYPE			m_nType;
		VIndex						m_nPosition;
		VIndex						m_nLength;
		VString 					m_vstrText;
		int							m_nTokenValue;
};

// This is our comparator class, for use with the std::map class
struct StrComp_For_Map_Less {
	bool operator()( const VString &a, const VString &b ) const
	{
		// We have to perform a case-sensitive comparison, since entities are actually
		// case sensitive (like dagger vs Dagger).
		return (CR_SMALLER == a.CompareTo( b, true ));
	}
};

static bool GetEntityValue( const VString &inEntityName, UniChar &outReplacement )
{
	typedef std::map< VString, UniChar, StrComp_For_Map_Less > EntityMap;
	static EntityMap sEntityMap;
	if (!sEntityMap.size()) {
		// Thank goodness for regular expressions.  This list was pulled from the HTML 4.01 specification, found here:
		// <http://www.w3.org/TR/html4/sgml/entities.html>, and it was generated by the following regular expression:
		//		search: <!ENTITY[ ]*\([A-Za-z0-9]*\)[ ]*CDATA[ ]*\"&#\([0-9]+\);\"[ ]*--
		//		replace: sEntityMap\[ CVSTR( \"\1\" ) \] = (UniChar)\2; //
		// There was a bit of post-processing required because some of the comments spanned multiple lines, but it sure
		// saved a ton of typing.
		sEntityMap[ CVSTR( "nbsp" ) ] = (UniChar)160; // no-break space = non-breaking space, U+00A0 ISOnum
		sEntityMap[ CVSTR( "iexcl" ) ] = (UniChar)161; // inverted exclamation mark, U+00A1 ISOnum
		sEntityMap[ CVSTR( "cent" ) ] = (UniChar)162; // cent sign, U+00A2 ISOnum
		sEntityMap[ CVSTR( "pound" ) ] = (UniChar)163; // pound sign, U+00A3 ISOnum
		sEntityMap[ CVSTR( "curren" ) ] = (UniChar)164; // currency sign, U+00A4 ISOnum
		sEntityMap[ CVSTR( "yen" ) ] = (UniChar)165; // yen sign = yuan sign, U+00A5 ISOnum
		sEntityMap[ CVSTR( "brvbar" ) ] = (UniChar)166; // broken bar = broken vertical bar, U+00A6 ISOnum
		sEntityMap[ CVSTR( "sect" ) ] = (UniChar)167; // section sign, U+00A7 ISOnum
		sEntityMap[ CVSTR( "uml" ) ] = (UniChar)168; // diaeresis = spacing diaeresis, U+00A8 ISOdia
		sEntityMap[ CVSTR( "copy" ) ] = (UniChar)169; // copyright sign, U+00A9 ISOnum
		sEntityMap[ CVSTR( "ordf" ) ] = (UniChar)170; // feminine ordinal indicator, U+00AA ISOnum
		sEntityMap[ CVSTR( "laquo" ) ] = (UniChar)171; // left-pointing double angle quotation mark = left pointing guillemet, U+00AB ISOnum
		sEntityMap[ CVSTR( "not" ) ] = (UniChar)172; // not sign, U+00AC ISOnum
		sEntityMap[ CVSTR( "shy" ) ] = (UniChar)173; // soft hyphen = discretionary hyphen, U+00AD ISOnum
		sEntityMap[ CVSTR( "reg" ) ] = (UniChar)174; // registered sign = registered trade mark sign, U+00AE ISOnum
		sEntityMap[ CVSTR( "macr" ) ] = (UniChar)175; // macron = spacing macron = overline = APL overbar, U+00AF ISOdia
		sEntityMap[ CVSTR( "deg" ) ] = (UniChar)176; // degree sign, U+00B0 ISOnum
		sEntityMap[ CVSTR( "plusmn" ) ] = (UniChar)177; // plus-minus sign = plus-or-minus sign, U+00B1 ISOnum
		sEntityMap[ CVSTR( "sup2" ) ] = (UniChar)178; // superscript two = superscript digit two = squared, U+00B2 ISOnum
		sEntityMap[ CVSTR( "sup3" ) ] = (UniChar)179; // superscript three = superscript digit three = cubed, U+00B3 ISOnum
		sEntityMap[ CVSTR( "acute" ) ] = (UniChar)180; // acute accent = spacing acute, U+00B4 ISOdia
		sEntityMap[ CVSTR( "micro" ) ] = (UniChar)181; // micro sign, U+00B5 ISOnum
		sEntityMap[ CVSTR( "para" ) ] = (UniChar)182; // pilcrow sign = paragraph sign, U+00B6 ISOnum
		sEntityMap[ CVSTR( "middot" ) ] = (UniChar)183; // middle dot = Georgian comma = Greek middle dot, U+00B7 ISOnum
		sEntityMap[ CVSTR( "cedil" ) ] = (UniChar)184; // cedilla = spacing cedilla, U+00B8 ISOdia
		sEntityMap[ CVSTR( "sup1" ) ] = (UniChar)185; // superscript one = superscript digit one, U+00B9 ISOnum
		sEntityMap[ CVSTR( "ordm" ) ] = (UniChar)186; // masculine ordinal indicator, U+00BA ISOnum
		sEntityMap[ CVSTR( "raquo" ) ] = (UniChar)187; // right-pointing double angle quotation mark = right pointing guillemet, U+00BB ISOnum
		sEntityMap[ CVSTR( "frac14" ) ] = (UniChar)188; // vulgar fraction one quarter = fraction one quarter, U+00BC ISOnum
		sEntityMap[ CVSTR( "frac12" ) ] = (UniChar)189; // vulgar fraction one half = fraction one half, U+00BD ISOnum
		sEntityMap[ CVSTR( "frac34" ) ] = (UniChar)190; // vulgar fraction three quarters = fraction three quarters, U+00BE ISOnum
		sEntityMap[ CVSTR( "iquest" ) ] = (UniChar)191; // inverted question mark = turned question mark, U+00BF ISOnum
		sEntityMap[ CVSTR( "Agrave" ) ] = (UniChar)192; // latin capital letter A with grave = latin capital letter A grave, U+00C0 ISOlat1
		sEntityMap[ CVSTR( "Aacute" ) ] = (UniChar)193; // latin capital letter A with acute, U+00C1 ISOlat1
		sEntityMap[ CVSTR( "Acirc" ) ] = (UniChar)194; // latin capital letter A with circumflex, U+00C2 ISOlat1
		sEntityMap[ CVSTR( "Atilde" ) ] = (UniChar)195; // latin capital letter A with tilde, U+00C3 ISOlat1
		sEntityMap[ CVSTR( "Auml" ) ] = (UniChar)196; // latin capital letter A with diaeresis, U+00C4 ISOlat1
		sEntityMap[ CVSTR( "Aring" ) ] = (UniChar)197; // latin capital letter A with ring above = latin capital letter A ring, U+00C5 ISOlat1
		sEntityMap[ CVSTR( "AElig" ) ] = (UniChar)198; // latin capital letter AE = latin capital ligature AE, U+00C6 ISOlat1
		sEntityMap[ CVSTR( "Ccedil" ) ] = (UniChar)199; // latin capital letter C with cedilla, U+00C7 ISOlat1
		sEntityMap[ CVSTR( "Egrave" ) ] = (UniChar)200; // latin capital letter E with grave, U+00C8 ISOlat1
		sEntityMap[ CVSTR( "Eacute" ) ] = (UniChar)201; // latin capital letter E with acute, U+00C9 ISOlat1
		sEntityMap[ CVSTR( "Ecirc" ) ] = (UniChar)202; // latin capital letter E with circumflex, U+00CA ISOlat1
		sEntityMap[ CVSTR( "Euml" ) ] = (UniChar)203; // latin capital letter E with diaeresis, U+00CB ISOlat1
		sEntityMap[ CVSTR( "Igrave" ) ] = (UniChar)204; // latin capital letter I with grave, U+00CC ISOlat1
		sEntityMap[ CVSTR( "Iacute" ) ] = (UniChar)205; // latin capital letter I with acute, U+00CD ISOlat1
		sEntityMap[ CVSTR( "Icirc" ) ] = (UniChar)206; // latin capital letter I with circumflex, U+00CE ISOlat1
		sEntityMap[ CVSTR( "Iuml" ) ] = (UniChar)207; // latin capital letter I with diaeresis, U+00CF ISOlat1
		sEntityMap[ CVSTR( "ETH" ) ] = (UniChar)208; // latin capital letter ETH, U+00D0 ISOlat1
		sEntityMap[ CVSTR( "Ntilde" ) ] = (UniChar)209; // latin capital letter N with tilde, U+00D1 ISOlat1
		sEntityMap[ CVSTR( "Ograve" ) ] = (UniChar)210; // latin capital letter O with grave, U+00D2 ISOlat1
		sEntityMap[ CVSTR( "Oacute" ) ] = (UniChar)211; // latin capital letter O with acute, U+00D3 ISOlat1
		sEntityMap[ CVSTR( "Ocirc" ) ] = (UniChar)212; // latin capital letter O with circumflex, U+00D4 ISOlat1
		sEntityMap[ CVSTR( "Otilde" ) ] = (UniChar)213; // latin capital letter O with tilde, U+00D5 ISOlat1
		sEntityMap[ CVSTR( "Ouml" ) ] = (UniChar)214; // latin capital letter O with diaeresis, U+00D6 ISOlat1
		sEntityMap[ CVSTR( "times" ) ] = (UniChar)215; // multiplication sign, U+00D7 ISOnum
		sEntityMap[ CVSTR( "Oslash" ) ] = (UniChar)216; // latin capital letter O with stroke = latin capital letter O slash, U+00D8 ISOlat1
		sEntityMap[ CVSTR( "Ugrave" ) ] = (UniChar)217; // latin capital letter U with grave, U+00D9 ISOlat1
		sEntityMap[ CVSTR( "Uacute" ) ] = (UniChar)218; // latin capital letter U with acute, U+00DA ISOlat1
		sEntityMap[ CVSTR( "Ucirc" ) ] = (UniChar)219; // latin capital letter U with circumflex, U+00DB ISOlat1
		sEntityMap[ CVSTR( "Uuml" ) ] = (UniChar)220; // latin capital letter U with diaeresis, U+00DC ISOlat1
		sEntityMap[ CVSTR( "Yacute" ) ] = (UniChar)221; // latin capital letter Y with acute, U+00DD ISOlat1
		sEntityMap[ CVSTR( "THORN" ) ] = (UniChar)222; // latin capital letter THORN, U+00DE ISOlat1
		sEntityMap[ CVSTR( "szlig" ) ] = (UniChar)223; // latin small letter sharp s = ess-zed, U+00DF ISOlat1
		sEntityMap[ CVSTR( "agrave" ) ] = (UniChar)224; // latin small letter a with grave = latin small letter a grave, U+00E0 ISOlat1
		sEntityMap[ CVSTR( "aacute" ) ] = (UniChar)225; // latin small letter a with acute, U+00E1 ISOlat1
		sEntityMap[ CVSTR( "acirc" ) ] = (UniChar)226; // latin small letter a with circumflex, U+00E2 ISOlat1
		sEntityMap[ CVSTR( "atilde" ) ] = (UniChar)227; // latin small letter a with tilde, U+00E3 ISOlat1
		sEntityMap[ CVSTR( "auml" ) ] = (UniChar)228; // latin small letter a with diaeresis, U+00E4 ISOlat1
		sEntityMap[ CVSTR( "aring" ) ] = (UniChar)229; // latin small letter a with ring above = latin small letter a ring, U+00E5 ISOlat1
		sEntityMap[ CVSTR( "aelig" ) ] = (UniChar)230; // latin small letter ae = latin small ligature ae, U+00E6 ISOlat1
		sEntityMap[ CVSTR( "ccedil" ) ] = (UniChar)231; // latin small letter c with cedilla, U+00E7 ISOlat1
		sEntityMap[ CVSTR( "egrave" ) ] = (UniChar)232; // latin small letter e with grave, U+00E8 ISOlat1
		sEntityMap[ CVSTR( "eacute" ) ] = (UniChar)233; // latin small letter e with acute, U+00E9 ISOlat1
		sEntityMap[ CVSTR( "ecirc" ) ] = (UniChar)234; // latin small letter e with circumflex, U+00EA ISOlat1
		sEntityMap[ CVSTR( "euml" ) ] = (UniChar)235; // latin small letter e with diaeresis, U+00EB ISOlat1
		sEntityMap[ CVSTR( "igrave" ) ] = (UniChar)236; // latin small letter i with grave, U+00EC ISOlat1
		sEntityMap[ CVSTR( "iacute" ) ] = (UniChar)237; // latin small letter i with acute, U+00ED ISOlat1
		sEntityMap[ CVSTR( "icirc" ) ] = (UniChar)238; // latin small letter i with circumflex, U+00EE ISOlat1
		sEntityMap[ CVSTR( "iuml" ) ] = (UniChar)239; // latin small letter i with diaeresis, U+00EF ISOlat1
		sEntityMap[ CVSTR( "eth" ) ] = (UniChar)240; // latin small letter eth, U+00F0 ISOlat1
		sEntityMap[ CVSTR( "ntilde" ) ] = (UniChar)241; // latin small letter n with tilde, U+00F1 ISOlat1
		sEntityMap[ CVSTR( "ograve" ) ] = (UniChar)242; // latin small letter o with grave, U+00F2 ISOlat1
		sEntityMap[ CVSTR( "oacute" ) ] = (UniChar)243; // latin small letter o with acute, U+00F3 ISOlat1
		sEntityMap[ CVSTR( "ocirc" ) ] = (UniChar)244; // latin small letter o with circumflex, U+00F4 ISOlat1
		sEntityMap[ CVSTR( "otilde" ) ] = (UniChar)245; // latin small letter o with tilde, U+00F5 ISOlat1
		sEntityMap[ CVSTR( "ouml" ) ] = (UniChar)246; // latin small letter o with diaeresis, U+00F6 ISOlat1
		sEntityMap[ CVSTR( "divide" ) ] = (UniChar)247; // division sign, U+00F7 ISOnum
		sEntityMap[ CVSTR( "oslash" ) ] = (UniChar)248; // latin small letter o with stroke, = latin small letter o slash, U+00F8 ISOlat1
		sEntityMap[ CVSTR( "ugrave" ) ] = (UniChar)249; // latin small letter u with grave, U+00F9 ISOlat1
		sEntityMap[ CVSTR( "uacute" ) ] = (UniChar)250; // latin small letter u with acute, U+00FA ISOlat1
		sEntityMap[ CVSTR( "ucirc" ) ] = (UniChar)251; // latin small letter u with circumflex, U+00FB ISOlat1
		sEntityMap[ CVSTR( "uuml" ) ] = (UniChar)252; // latin small letter u with diaeresis, U+00FC ISOlat1
		sEntityMap[ CVSTR( "yacute" ) ] = (UniChar)253; // latin small letter y with acute, U+00FD ISOlat1
		sEntityMap[ CVSTR( "thorn" ) ] = (UniChar)254; // latin small letter thorn, U+00FE ISOlat1
		sEntityMap[ CVSTR( "yuml" ) ] = (UniChar)255; // latin small letter y with diaeresis, U+00FF ISOlat1
		sEntityMap[ CVSTR( "fnof" ) ] = (UniChar)402; // latin small f with hook = function = florin, U+0192 ISOtech
		sEntityMap[ CVSTR( "Alpha" ) ] = (UniChar)913; // greek capital letter alpha, U+0391
		sEntityMap[ CVSTR( "Beta" ) ] = (UniChar)914; // greek capital letter beta, U+0392
		sEntityMap[ CVSTR( "Gamma" ) ] = (UniChar)915; // greek capital letter gamma, U+0393 ISOgrk3
		sEntityMap[ CVSTR( "Delta" ) ] = (UniChar)916; // greek capital letter delta, U+0394 ISOgrk3
		sEntityMap[ CVSTR( "Epsilon" ) ] = (UniChar)917; // greek capital letter epsilon, U+0395
		sEntityMap[ CVSTR( "Zeta" ) ] = (UniChar)918; // greek capital letter zeta, U+0396
		sEntityMap[ CVSTR( "Eta" ) ] = (UniChar)919; // greek capital letter eta, U+0397
		sEntityMap[ CVSTR( "Theta" ) ] = (UniChar)920; // greek capital letter theta, U+0398 ISOgrk3
		sEntityMap[ CVSTR( "Iota" ) ] = (UniChar)921; // greek capital letter iota, U+0399
		sEntityMap[ CVSTR( "Kappa" ) ] = (UniChar)922; // greek capital letter kappa, U+039A
		sEntityMap[ CVSTR( "Lambda" ) ] = (UniChar)923; // greek capital letter lambda, U+039B ISOgrk3
		sEntityMap[ CVSTR( "Mu" ) ] = (UniChar)924; // greek capital letter mu, U+039C
		sEntityMap[ CVSTR( "Nu" ) ] = (UniChar)925; // greek capital letter nu, U+039D
		sEntityMap[ CVSTR( "Xi" ) ] = (UniChar)926; // greek capital letter xi, U+039E ISOgrk3
		sEntityMap[ CVSTR( "Omicron" ) ] = (UniChar)927; // greek capital letter omicron, U+039F
		sEntityMap[ CVSTR( "Pi" ) ] = (UniChar)928; // greek capital letter pi, U+03A0 ISOgrk3
		sEntityMap[ CVSTR( "Rho" ) ] = (UniChar)929; // greek capital letter rho, U+03A1
		sEntityMap[ CVSTR( "Sigma" ) ] = (UniChar)931; // greek capital letter sigma, U+03A3 ISOgrk3
		sEntityMap[ CVSTR( "Tau" ) ] = (UniChar)932; // greek capital letter tau, U+03A4
		sEntityMap[ CVSTR( "Upsilon" ) ] = (UniChar)933; // greek capital letter upsilon, U+03A5 ISOgrk3
		sEntityMap[ CVSTR( "Phi" ) ] = (UniChar)934; // greek capital letter phi, U+03A6 ISOgrk3
		sEntityMap[ CVSTR( "Chi" ) ] = (UniChar)935; // greek capital letter chi, U+03A7
		sEntityMap[ CVSTR( "Psi" ) ] = (UniChar)936; // greek capital letter psi, U+03A8 ISOgrk3
		sEntityMap[ CVSTR( "Omega" ) ] = (UniChar)937; // greek capital letter omega, U+03A9 ISOgrk3
		sEntityMap[ CVSTR( "alpha" ) ] = (UniChar)945; // greek small letter alpha, U+03B1 ISOgrk3
		sEntityMap[ CVSTR( "beta" ) ] = (UniChar)946; // greek small letter beta, U+03B2 ISOgrk3
		sEntityMap[ CVSTR( "gamma" ) ] = (UniChar)947; // greek small letter gamma, U+03B3 ISOgrk3
		sEntityMap[ CVSTR( "delta" ) ] = (UniChar)948; // greek small letter delta, U+03B4 ISOgrk3
		sEntityMap[ CVSTR( "epsilon" ) ] = (UniChar)949; // greek small letter epsilon, U+03B5 ISOgrk3
		sEntityMap[ CVSTR( "zeta" ) ] = (UniChar)950; // greek small letter zeta, U+03B6 ISOgrk3
		sEntityMap[ CVSTR( "eta" ) ] = (UniChar)951; // greek small letter eta, U+03B7 ISOgrk3
		sEntityMap[ CVSTR( "theta" ) ] = (UniChar)952; // greek small letter theta, U+03B8 ISOgrk3
		sEntityMap[ CVSTR( "iota" ) ] = (UniChar)953; // greek small letter iota, U+03B9 ISOgrk3
		sEntityMap[ CVSTR( "kappa" ) ] = (UniChar)954; // greek small letter kappa, U+03BA ISOgrk3
		sEntityMap[ CVSTR( "lambda" ) ] = (UniChar)955; // greek small letter lambda, U+03BB ISOgrk3
		sEntityMap[ CVSTR( "mu" ) ] = (UniChar)956; // greek small letter mu, U+03BC ISOgrk3
		sEntityMap[ CVSTR( "nu" ) ] = (UniChar)957; // greek small letter nu, U+03BD ISOgrk3
		sEntityMap[ CVSTR( "xi" ) ] = (UniChar)958; // greek small letter xi, U+03BE ISOgrk3
		sEntityMap[ CVSTR( "omicron" ) ] = (UniChar)959; // greek small letter omicron, U+03BF NEW
		sEntityMap[ CVSTR( "pi" ) ] = (UniChar)960; // greek small letter pi, U+03C0 ISOgrk3
		sEntityMap[ CVSTR( "rho" ) ] = (UniChar)961; // greek small letter rho, U+03C1 ISOgrk3
		sEntityMap[ CVSTR( "sigmaf" ) ] = (UniChar)962; // greek small letter final sigma, U+03C2 ISOgrk3
		sEntityMap[ CVSTR( "sigma" ) ] = (UniChar)963; // greek small letter sigma, U+03C3 ISOgrk3
		sEntityMap[ CVSTR( "tau" ) ] = (UniChar)964; // greek small letter tau, U+03C4 ISOgrk3
		sEntityMap[ CVSTR( "upsilon" ) ] = (UniChar)965; // greek small letter upsilon, U+03C5 ISOgrk3
		sEntityMap[ CVSTR( "phi" ) ] = (UniChar)966; // greek small letter phi, U+03C6 ISOgrk3
		sEntityMap[ CVSTR( "chi" ) ] = (UniChar)967; // greek small letter chi, U+03C7 ISOgrk3
		sEntityMap[ CVSTR( "psi" ) ] = (UniChar)968; // greek small letter psi, U+03C8 ISOgrk3
		sEntityMap[ CVSTR( "omega" ) ] = (UniChar)969; // greek small letter omega, U+03C9 ISOgrk3
		sEntityMap[ CVSTR( "thetasym" ) ] = (UniChar)977; // greek small letter theta symbol, U+03D1 NEW
		sEntityMap[ CVSTR( "upsih" ) ] = (UniChar)978; // greek upsilon with hook symbol, U+03D2 NEW
		sEntityMap[ CVSTR( "piv" ) ] = (UniChar)982; // greek pi symbol, U+03D6 ISOgrk3
		sEntityMap[ CVSTR( "bull" ) ] = (UniChar)8226; // bullet = black small circle, U+2022 ISOpub 
		sEntityMap[ CVSTR( "hellip" ) ] = (UniChar)8230; // horizontal ellipsis = three dot leader, U+2026 ISOpub 
		sEntityMap[ CVSTR( "prime" ) ] = (UniChar)8242; // prime = minutes = feet, U+2032 ISOtech
		sEntityMap[ CVSTR( "Prime" ) ] = (UniChar)8243; // double prime = seconds = inches, U+2033 ISOtech
		sEntityMap[ CVSTR( "oline" ) ] = (UniChar)8254; // overline = spacing overscore, U+203E NEW
		sEntityMap[ CVSTR( "frasl" ) ] = (UniChar)8260; // fraction slash, U+2044 NEW
		sEntityMap[ CVSTR( "weierp" ) ] = (UniChar)8472; // script capital P = power set = Weierstrass p, U+2118 ISOamso
		sEntityMap[ CVSTR( "image" ) ] = (UniChar)8465; // blackletter capital I = imaginary part, U+2111 ISOamso
		sEntityMap[ CVSTR( "real" ) ] = (UniChar)8476; // blackletter capital R = real part symbol, U+211C ISOamso
		sEntityMap[ CVSTR( "trade" ) ] = (UniChar)8482; // trade mark sign, U+2122 ISOnum
		sEntityMap[ CVSTR( "alefsym" ) ] = (UniChar)8501; // alef symbol = first transfinite cardinal,
		sEntityMap[ CVSTR( "larr" ) ] = (UniChar)8592; // leftwards arrow, U+2190 ISOnum
		sEntityMap[ CVSTR( "uarr" ) ] = (UniChar)8593; // upwards arrow, U+2191 ISOnum-->
		sEntityMap[ CVSTR( "rarr" ) ] = (UniChar)8594; // rightwards arrow, U+2192 ISOnum
		sEntityMap[ CVSTR( "darr" ) ] = (UniChar)8595; // downwards arrow, U+2193 ISOnum
		sEntityMap[ CVSTR( "harr" ) ] = (UniChar)8596; // left right arrow, U+2194 ISOamsa
		sEntityMap[ CVSTR( "crarr" ) ] = (UniChar)8629; // downwards arrow with corner leftwards = carriage return, U+21B5 NEW
		sEntityMap[ CVSTR( "lArr" ) ] = (UniChar)8656; // leftwards double arrow, U+21D0 ISOtech
		sEntityMap[ CVSTR( "uArr" ) ] = (UniChar)8657; // upwards double arrow, U+21D1 ISOamsa
		sEntityMap[ CVSTR( "rArr" ) ] = (UniChar)8658; // rightwards double arrow, U+21D2 ISOtech
		sEntityMap[ CVSTR( "dArr" ) ] = (UniChar)8659; // downwards double arrow, U+21D3 ISOamsa
		sEntityMap[ CVSTR( "hArr" ) ] = (UniChar)8660; // left right double arrow,
		sEntityMap[ CVSTR( "forall" ) ] = (UniChar)8704; // for all, U+2200 ISOtech
		sEntityMap[ CVSTR( "part" ) ] = (UniChar)8706; // partial differential, U+2202 ISOtech 
		sEntityMap[ CVSTR( "exist" ) ] = (UniChar)8707; // there exists, U+2203 ISOtech
		sEntityMap[ CVSTR( "empty" ) ] = (UniChar)8709; // empty set = null set = diameter, U+2205 ISOamso
		sEntityMap[ CVSTR( "nabla" ) ] = (UniChar)8711; // nabla = backward difference, U+2207 ISOtech
		sEntityMap[ CVSTR( "isin" ) ] = (UniChar)8712; // element of, U+2208 ISOtech
		sEntityMap[ CVSTR( "notin" ) ] = (UniChar)8713; // not an element of, U+2209 ISOtech
		sEntityMap[ CVSTR( "ni" ) ] = (UniChar)8715; // contains as member, U+220B ISOtech
		sEntityMap[ CVSTR( "prod" ) ] = (UniChar)8719; // n-ary product = product sign, U+220F ISOamsb
		sEntityMap[ CVSTR( "sum" ) ] = (UniChar)8721; // n-ary sumation, U+2211 ISOamsb
		sEntityMap[ CVSTR( "minus" ) ] = (UniChar)8722; // minus sign, U+2212 ISOtech
		sEntityMap[ CVSTR( "lowast" ) ] = (UniChar)8727; // asterisk operator, U+2217 ISOtech
		sEntityMap[ CVSTR( "radic" ) ] = (UniChar)8730; // square root = radical sign, U+221A ISOtech
		sEntityMap[ CVSTR( "prop" ) ] = (UniChar)8733; // proportional to, U+221D ISOtech
		sEntityMap[ CVSTR( "infin" ) ] = (UniChar)8734; // infinity, U+221E ISOtech
		sEntityMap[ CVSTR( "ang" ) ] = (UniChar)8736; // angle, U+2220 ISOamso
		sEntityMap[ CVSTR( "and" ) ] = (UniChar)8743; // logical and = wedge, U+2227 ISOtech
		sEntityMap[ CVSTR( "or" ) ] = (UniChar)8744; // logical or = vee, U+2228 ISOtech
		sEntityMap[ CVSTR( "cap" ) ] = (UniChar)8745; // intersection = cap, U+2229 ISOtech
		sEntityMap[ CVSTR( "cup" ) ] = (UniChar)8746; // union = cup, U+222A ISOtech
		sEntityMap[ CVSTR( "int" ) ] = (UniChar)8747; // integral, U+222B ISOtech
		sEntityMap[ CVSTR( "there4" ) ] = (UniChar)8756; // therefore, U+2234 ISOtech
		sEntityMap[ CVSTR( "sim" ) ] = (UniChar)8764; // tilde operator = varies with = similar to, U+223C ISOtech
		sEntityMap[ CVSTR( "cong" ) ] = (UniChar)8773; // approximately equal to, U+2245 ISOtech
		sEntityMap[ CVSTR( "asymp" ) ] = (UniChar)8776; // almost equal to = asymptotic to, U+2248 ISOamsr
		sEntityMap[ CVSTR( "ne" ) ] = (UniChar)8800; // not equal to, U+2260 ISOtech
		sEntityMap[ CVSTR( "equiv" ) ] = (UniChar)8801; // identical to, U+2261 ISOtech
		sEntityMap[ CVSTR( "le" ) ] = (UniChar)8804; // less-than or equal to, U+2264 ISOtech
		sEntityMap[ CVSTR( "ge" ) ] = (UniChar)8805; // greater-than or equal to, U+2265 ISOtech
		sEntityMap[ CVSTR( "sub" ) ] = (UniChar)8834; // subset of, U+2282 ISOtech
		sEntityMap[ CVSTR( "sup" ) ] = (UniChar)8835; // superset of, U+2283 ISOtech
		sEntityMap[ CVSTR( "nsub" ) ] = (UniChar)8836; // not a subset of, U+2284 ISOamsn
		sEntityMap[ CVSTR( "sube" ) ] = (UniChar)8838; // subset of or equal to, U+2286 ISOtech
		sEntityMap[ CVSTR( "supe" ) ] = (UniChar)8839; // superset of or equal to, U+2287 ISOtech
		sEntityMap[ CVSTR( "oplus" ) ] = (UniChar)8853; // circled plus = direct sum, U+2295 ISOamsb
		sEntityMap[ CVSTR( "otimes" ) ] = (UniChar)8855; // circled times = vector product, U+2297 ISOamsb
		sEntityMap[ CVSTR( "perp" ) ] = (UniChar)8869; // up tack = orthogonal to = perpendicular, U+22A5 ISOtech
		sEntityMap[ CVSTR( "sdot" ) ] = (UniChar)8901; // dot operator, U+22C5 ISOamsb
		sEntityMap[ CVSTR( "lceil" ) ] = (UniChar)8968; // left ceiling = apl upstile, U+2308 ISOamsc 
		sEntityMap[ CVSTR( "rceil" ) ] = (UniChar)8969; // right ceiling, U+2309 ISOamsc 
		sEntityMap[ CVSTR( "lfloor" ) ] = (UniChar)8970; // left floor = apl downstile, U+230A ISOamsc 
		sEntityMap[ CVSTR( "rfloor" ) ] = (UniChar)8971; // right floor, U+230B ISOamsc 
		sEntityMap[ CVSTR( "lang" ) ] = (UniChar)9001; // left-pointing angle bracket = bra, U+2329 ISOtech
		sEntityMap[ CVSTR( "rang" ) ] = (UniChar)9002; // right-pointing angle bracket = ket, U+232A ISOtech
		sEntityMap[ CVSTR( "loz" ) ] = (UniChar)9674; // lozenge, U+25CA ISOpub
		sEntityMap[ CVSTR( "spades" ) ] = (UniChar)9824; // black spade suit, U+2660 ISOpub
		sEntityMap[ CVSTR( "clubs" ) ] = (UniChar)9827; // black club suit = shamrock, U+2663 ISOpub
		sEntityMap[ CVSTR( "hearts" ) ] = (UniChar)9829; // black heart suit = valentine, U+2665 ISOpub
		sEntityMap[ CVSTR( "diams" ) ] = (UniChar)9830; // black diamond suit, U+2666 ISOpub
		sEntityMap[ CVSTR( "quot" ) ] = (UniChar)34; // quotation mark = APL quote, U+0022 ISOnum
		sEntityMap[ CVSTR( "amp" ) ] = (UniChar)38; // ampersand, U+0026 ISOnum
		sEntityMap[ CVSTR( "lt" ) ] = (UniChar)60; // less-than sign, U+003C ISOnum
		sEntityMap[ CVSTR( "gt" ) ] = (UniChar)62; // greater-than sign, U+003E ISOnum
		sEntityMap[ CVSTR( "OElig" ) ] = (UniChar)338; // latin capital ligature OE, U+0152 ISOlat2
		sEntityMap[ CVSTR( "oelig" ) ] = (UniChar)339; // latin small ligature oe, U+0153 ISOlat2
		sEntityMap[ CVSTR( "Scaron" ) ] = (UniChar)352; // latin capital letter S with caron, U+0160 ISOlat2
		sEntityMap[ CVSTR( "scaron" ) ] = (UniChar)353; // latin small letter s with caron, U+0161 ISOlat2
		sEntityMap[ CVSTR( "Yuml" ) ] = (UniChar)376; // latin capital letter Y with diaeresis, U+0178 ISOlat2
		sEntityMap[ CVSTR( "circ" ) ] = (UniChar)710; // modifier letter circumflex accent, U+02C6 ISOpub
		sEntityMap[ CVSTR( "tilde" ) ] = (UniChar)732; // small tilde, U+02DC ISOdia
		sEntityMap[ CVSTR( "ensp" ) ] = (UniChar)8194; // en space, U+2002 ISOpub
		sEntityMap[ CVSTR( "emsp" ) ] = (UniChar)8195; // em space, U+2003 ISOpub
		sEntityMap[ CVSTR( "thinsp" ) ] = (UniChar)8201; // thin space, U+2009 ISOpub
		sEntityMap[ CVSTR( "zwnj" ) ] = (UniChar)8204; // zero width non-joiner, U+200C NEW RFC 2070
		sEntityMap[ CVSTR( "zwj" ) ] = (UniChar)8205; // zero width joiner, U+200D NEW RFC 2070
		sEntityMap[ CVSTR( "lrm" ) ] = (UniChar)8206; // left-to-right mark, U+200E NEW RFC 2070
		sEntityMap[ CVSTR( "rlm" ) ] = (UniChar)8207; // right-to-left mark, U+200F NEW RFC 2070
		sEntityMap[ CVSTR( "ndash" ) ] = (UniChar)8211; // en dash, U+2013 ISOpub
		sEntityMap[ CVSTR( "mdash" ) ] = (UniChar)8212; // em dash, U+2014 ISOpub
		sEntityMap[ CVSTR( "lsquo" ) ] = (UniChar)8216; // left single quotation mark, U+2018 ISOnum
		sEntityMap[ CVSTR( "rsquo" ) ] = (UniChar)8217; // right single quotation mark, U+2019 ISOnum
		sEntityMap[ CVSTR( "sbquo" ) ] = (UniChar)8218; // single low-9 quotation mark, U+201A NEW
		sEntityMap[ CVSTR( "ldquo" ) ] = (UniChar)8220; // left double quotation mark, U+201C ISOnum
		sEntityMap[ CVSTR( "rdquo" ) ] = (UniChar)8221; // right double quotation mark, U+201D ISOnum
		sEntityMap[ CVSTR( "bdquo" ) ] = (UniChar)8222; // double low-9 quotation mark, U+201E NEW
		sEntityMap[ CVSTR( "dagger" ) ] = (UniChar)8224; // dagger, U+2020 ISOpub
		sEntityMap[ CVSTR( "Dagger" ) ] = (UniChar)8225; // double dagger, U+2021 ISOpub
		sEntityMap[ CVSTR( "permil" ) ] = (UniChar)8240; // per mille sign, U+2030 ISOtech
		sEntityMap[ CVSTR( "lsaquo" ) ] = (UniChar)8249; // single left-pointing angle quotation mark, U+2039 ISO proposed
		sEntityMap[ CVSTR( "rsaquo" ) ] = (UniChar)8250; // single right-pointing angle quotation mark, U+203A ISO proposed
		sEntityMap[ CVSTR( "euro" ) ] = (UniChar)8364; // euro sign, U+20AC NEW
	}

	EntityMap::iterator iter = sEntityMap.find( inEntityName );
	if (iter != sEntityMap.end()) {
		outReplacement = iter->second;
		return true;
	}
	return false;
}

void HTMLLexer::ReportLexerError( VError inError, const char *inMessage )
{
	// We don't actually have to report any lexer errors since this is not being
	// used for actual compilation.  Basically, errors are expected and will be
	// ignored anyways!
}

bool HTMLLexer::IsWhitespace( UniChar inChar )
{
	// I'm just going to go with whatever JavaScript did, because the HTML spec doesn't
	// have a strict definition of whitespace
	switch (inChar) {
		case CHAR_SPACE:			// Space
		case CHAR_CONTROL_0009:		// Tab
		case CHAR_CONTROL_000B:		// Vertical Tab
		case CHAR_CONTROL_000C:		// Form Feed
		case CHAR_NO_BREAK_SPACE:	// Non-breaking space
			return true;
	}

	// We also want to check the Zs "whitespace" category
	if (U_GET_GC_MASK( inChar ) & (U_GC_ZS_MASK))	// Letter number
		return true;

	return false;
}

bool HTMLLexer::IsLineEnding( UniChar inChar )
{
	switch (inChar) {
		case CHAR_CONTROL_000D:		// Carriage return
		case CHAR_CONTROL_000A:		// Line feed
		case CHAR_LINE_SEPARATOR:
		case CHAR_PARAGRAPH_SEPARATOR: {
			fLineNumber++;
			return true;
		} break;
	}

	return false;
}

const sLONG kHTMLMultilineComment = 'HTml';
bool HTMLLexer::IsMultiLineCommentStart( UniChar inChar, sLONG &outType )
{
	// We are looking for <!--, which requires three more tokens of lookahead.
	if (CHAR_LESS_THAN_SIGN != inChar)	return false;
	if (!fLexerInput->HasMoreChars())	return false;

	VString subStr;
	fLexerInput->GetSubString( fLexerInput->GetCurrentPosition(), 4, subStr );


	if (subStr.EqualTo( CVSTR( "<!--" ), false )) {
		outType = kHTMLMultilineComment;
		return true;
	}

	return false;
}

bool HTMLLexer::IsMultiLineCommentEnd( UniChar inChar, sLONG &outCharsToConsume, sLONG inType )
{
	// We have to check for newlines for no other reason than bookkeeping.  This records when we
	// locate a newline so that the fLineNumber property remains properly in-sync.  We will consume
	// the newline for the caller if that's what we've gotten.
	if (IsLineEnding( inChar ))	ConsumeLineEnding( inChar );

	// We are looking for -->
	if (inType != kCommentContinuationType &&
		inType != kHTMLMultilineComment)				return false;
	if (CHAR_HYPHEN_MINUS != inChar)					return false;
	if (!fLexerInput->HasMoreChars())					return false;

	VString subStr;
	fLexerInput->GetSubString( fLexerInput->GetCurrentPosition() + 1, 2, subStr );
	if (subStr.EqualTo( CVSTR( "->" ), false )) {
		// We're at the end of the comment, but the caller still needs to consume two characters
		outCharsToConsume = 2;
		return true;
	}
	return false;
}

bool HTMLLexer::ConsumeMultiLineComment( TokenList *ioTokens, sLONG inType )
{
	// We have to override the default behavior for multiline comment consumption because we define
	// a bunch of "special" comment types for 4D.  So we will let the default consumer do its job, but
	// we will look at the comment that was consumed afterwards to see if we have a special comment
	// type.  If we do, we need only modify the token's type accordingly.
	bool ret = VLexerBase::ConsumeMultiLineComment( ioTokens, inType );

	// Look at the last token in the list (it should be a comment or an open comment), and grab its text
	ILexerToken *token = ioTokens->back();
	xbox_assert( token->GetType() == ILexerToken::TT_COMMENT || token->GetType() == ILexerToken::TT_OPEN_COMMENT );

	// For right now, we only care about finished comments because it makes the logic easier.  We don't have to
	// worry so much about handling the syntax highlighting aspects of things.
	VString tokenText = token->GetText();
	if (token->GetType() == ILexerToken::TT_COMMENT && tokenText.BeginsWith( CVSTR( "<!--#4D" ) )) {
		// We probably have one of the special comment types.  We're going to remove the old token and create a new
		// one with the appropriate information, but only after we've verified that this isn't just garbage!
		if (tokenText.BeginsWith( CVSTR( "<!--#4DVAR" ) ) ||
			tokenText.BeginsWith( CVSTR( "<!--#4DHTMLVAR" ) ) ||
			tokenText.BeginsWith( CVSTR( "<!--#4DINCLUDE" ) ) ||
			tokenText.BeginsWith( CVSTR( "<!--#4DACTION" ) ) ||
			tokenText.BeginsWith( CVSTR( "<!--#4DSCRIPT" ) ) ||
			tokenText.BeginsWith( CVSTR( "<!--#4DMETHOD" ) ) ||
			tokenText.BeginsWith( CVSTR( "<!--#4DIF" ) ) ||
			tokenText.BeginsWith( CVSTR( "<!--#4DELSE" ) ) ||
			tokenText.BeginsWith( CVSTR( "<!--#4DENDIF" ) ) ||
			tokenText.BeginsWith( CVSTR( "<!--#4DLOOP" ) ) ||
			tokenText.BeginsWith( CVSTR( "<!--#4DENDLOOP" ) )) {
				ioTokens->pop_back();
				ioTokens->push_back( new HTMLLexerToken( ILexerToken::TT_SPECIAL_4D_COMMENT, token->GetPosition(), token->GetLength(), tokenText, token->GetValue() ) );
		}
	}

	return ret;
}

const sLONG kApostropheString = 'apST';
const sLONG kQuoteString = 'qtST';
bool HTMLLexer::IsStringStart( UniChar inChar, sLONG &outType, sLONG &outValue )
{
	// We can use single or double quotes for string literals
	if (CHAR_APOSTROPHE == inChar) {
		outType = kApostropheString;
		outValue = HTMLLexemes::STRING;
		return true;
	} else if (CHAR_QUOTATION_MARK == inChar) {
		outType = kQuoteString;
		outValue = HTMLLexemes::STRING;
		return true;
	}

	return false;
}

bool HTMLLexer::IsStringEnd( UniChar inChar, sLONG inType )
{
	// We have to end the string with the correct closing quote mark, be it single or double
	if (kApostropheString == inType && CHAR_APOSTROPHE == inChar) {
		return true;
	} else if (kQuoteString == inType && CHAR_QUOTATION_MARK == inChar) {
		return true;
	}

	return false;
}

bool HTMLLexer::IsStringEscapeSequence( UniChar inChar, sLONG inType )
{
	return false;
}

static bool isHexDigit( UniChar c )
{
	return ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'));
}

static bool isDecimalDigit( UniChar c )
{
	return (c >= '0' && c <= '9');
}

static sLONG getHexValueFromCharacter( UniChar c )
{
	if (c >= '0' && c <= '9') {
		return c - '0';
	} else if (c >= 'a' && c <= 'f') {
		return 10 + (c - 'a');
	} else if (c >= 'A' && c <= 'F') {
		return 10 + (c - 'A');	
	}

	xbox_assert( false );
	return 0;
}

static unsigned short sixteenToThePowerOf( sLONG i )
{
	// This is a specialized helper function that is called to quickly get
	// us powers of sixteen.  Basically, this is used when lexing the stream
	// of escape sequences.  We know there will never be an escape sequence of
	// more than four characters, so we only need four powers of sixteen.
	switch (i) {
		case 0:	return 1;
		case 1: return 16;
		case 2: return 256;
		case 3: return 4096;
	}
	xbox_assert( false );
	return 0;
}

static unsigned short tenToThePowerOf( sLONG i )
{
	// This is a specialized helper function that is called to quickly get
	// us powers of ten.  Basically, this is used when lexing the stream
	// of escape sequences.  We know there will never be an escape sequence of
	// more than five characters, so we only need five powers of ten.
	switch (i) {
		case 0:	return 1;
		case 1: return 10;
		case 2: return 100;
		case 3: return 1000;
		case 4:	return 10000;
	}
	xbox_assert( false );
	return 0;
}

bool HTMLLexer::ConsumeEscapeSequence( sLONG inType, UniChar &outCharacterToAdd )
{
	return false;
}

bool HTMLLexer::ConsumePossibleEntity( VString &outEntityConsumed, UniChar &outCharacterToAdd )
{
	if (!fLexerInput->HasMoreChars())	return false;
	xbox_assert( fLexerInput->PeekAtNextChar() == CHAR_AMPERSAND );

	// In HTML, escape sequences come in one of three forms:
	//	&#DDDD; (where D is decimal number)
	//	&#xHHHH; (where H is hexidecimal number -- case insensitive)
	//	&entity; (where entity is a common entity reference)
	// We've already read the ampersand, so now we want to figure out which of
	// the three cases we're dealing with.  If we don't match any of the three
	// cases, then we just assume we really had regular text and the user just
	// screwed up.

	// Consume the current character to see what sort of escape sequence we're dealing with
	fLexerInput->MoveToNextChar();	// Eat the &
	if (!fLexerInput->HasMoreChars()) {
		fLexerInput->MoveToPreviousChar();
		return false;
	}
	UniChar escapeType = fLexerInput->MoveToNextChar();
	sLONG charactersToRevert = 2;
	outEntityConsumed = "&";
	outEntityConsumed.AppendUniChar( escapeType );
	switch (escapeType) {
		case CHAR_NUMBER_SIGN: {
			// We either have a hex literal or a decimal literal following the # sign.  So we
			// will check to see which we've got and go from there
			if (!fLexerInput->HasMoreChars())	break;
			UniChar literalType = fLexerInput->MoveToNextChar();
			outEntityConsumed.AppendUniChar( literalType );
			charactersToRevert++;
			switch (literalType) {
				case CHAR_LATIN_CAPITAL_LETTER_X:
				case CHAR_LATIN_SMALL_LETTER_X: {
					// We now want to add any number of hex digits to the stream.  Though, if we go over
					// four hex digits, then we're outside of the range of any legal unicode code point, and
					// so I am going to do a hard-coded stop there.
					unsigned short value = 0;

					for (sLONG i = 0; i < 4; i++) {
						UniChar c = CHAR_CONTROL_0000;
						if (fLexerInput->HasMoreChars()) {
							c = fLexerInput->MoveToNextChar();
							charactersToRevert++;
							if (!isHexDigit( c ))	break;
							// Now we want to add the hex digit we got into our ultimate value
							value += sixteenToThePowerOf( i ) * getHexValueFromCharacter( c );
							outEntityConsumed.AppendUniChar( c );
						} else break;
					}

					// The last character needs to be a semi-colon, or else it's not a legal entity
					if (!fLexerInput->HasMoreChars()) break;
					if (fLexerInput->MoveToNextChar() != CHAR_SEMICOLON) {
						charactersToRevert++;
						break;
					}

					outEntityConsumed.AppendUniChar( ';' );

					// Add the value as a UniChar to our stream
					outCharacterToAdd = (UniChar)value;
					return true;
				} break;
				default: {
					// We want to test to see whether the character we read is a legal decimal digit.  If it
					// is, then we have a character literal.  If not, the user screwed up and we can just bail.
					if (isDecimalDigit( literalType )) {
						// We're going to put the character back just to parse it again.  It makes the logic easier
						fLexerInput->MoveToPreviousChar();

						// We know that we've got some digits we care about.  Now we need to find out how many,
						// and we'll put the cap at something sensible, like 5 characters (which can cover all of
						// the unicode code points in existence).
						unsigned short value = 0;

						for (sLONG i = 0; i < 5; i++) {
							UniChar c = CHAR_CONTROL_0000;
							if (fLexerInput->HasMoreChars()) {
								c = fLexerInput->MoveToNextChar();
								charactersToRevert++;
								if (!isDecimalDigit( c ))	break;
								// Now we want to add the decimal digit we got into our ultimate value
								value += tenToThePowerOf( i ) * (c - '0');
								outEntityConsumed.AppendUniChar( c );
							} else break;
						}

						// The last character needs to be a semi-colon, or else it's not a legal entity
						if (!fLexerInput->HasMoreChars()) break;
						if (fLexerInput->MoveToNextChar() != CHAR_SEMICOLON) {
							charactersToRevert++;
							break;
						}

						outEntityConsumed.AppendUniChar( ';' );

						// Add the value as a UniChar to our stream
						outCharacterToAdd = (UniChar)value;
						return true;
					} else break;
				} break;
			}
		} break;
		default: {
			// We found an ampersand and know it's not a numeric literal.  Now we need to see whether it's an
			// entity made to be a bit more human readable.  We're going to grab a bunch of characters from the
			// stream without actually shifting them in.  We cut them off at the semi-colon because all entities
			// must end with one to be legal.  Then, if it matches a known entity, we're set -- otherwise it's just
			// a stream of random characters.  We need a whopping nine character to be able to support &thetasym;
			VString entityName;
			fLexerInput->GetSubString( fLexerInput->GetCurrentPosition(), 9, entityName );

			// Now, let's see where the semi-colon is, and strip it off (as well as everything past it).  If we don't
			// find a semi-colon, then we know we don't have an entity
			VectorOfVString subStrs;
			if (!entityName.GetSubStrings( CHAR_SEMICOLON, subStrs ))	break;

			// The first sub string is the entity name we care about
			if (GetEntityValue( subStrs.front(), outCharacterToAdd )) {
				// We want to eat up as many characters as the entity was consuming
				VIndex size = subStrs.front().GetLength();
				for (VIndex i = 0; i < size; i++) {
					outEntityConsumed.AppendUniChar( fLexerInput->MoveToNextChar() );
				}
				return true;
			}
		} break;
	}

	// Put back the characters we screwed up on
	for (sLONG i = 0; i < charactersToRevert; i++)	fLexerInput->MoveToPreviousChar();

	return false;
}

bool HTMLLexer::IsIdentifierStart( UniChar inChar )
{
	// We don't really have identifiers in HTML -- we just claim it's plain text.  And that can
	// be anything that's not a literal or special punctuation.  So, we will pull out the things
	// which aren't strictly legal text, and everything else is considered the start of an identifier
	if (!IsWhitespace( inChar ) && !IsLineEnding( inChar ))	return true;
	return false;
}

bool HTMLLexer::IsIdentifierCharacter( UniChar inChar )
{
	return IsIdentifierStart( inChar ) && !(
			inChar == CHAR_SOLIDUS ||
			inChar == CHAR_LESS_THAN_SIGN ||
			inChar == CHAR_GREATER_THAN_SIGN ||
			inChar == CHAR_AMPERSAND ||
			inChar == CHAR_EQUALS_SIGN
		);
}

bool HTMLLexer::IsNumericStart( UniChar inChar, ENumericType &outType )
{
	return false;
}

bool HTMLLexer::ConsumeNumber( VString *ioNumber, TokenList *ioTokens, ENumericType &ioType )
{
	return false;
}

int HTMLLexer::ConsumePossiblePunctuation( UniChar inChar, TokenList *outTokens )
{
	VIndex nStartingPosition = fLexerInput->GetCurrentPosition();
	int tk = 0;
	VString tokenStr;
	switch (inChar) {
		case CHAR_AMPERSAND: {
			VString entity;
			UniChar ch;
			if (ConsumePossibleEntity( entity, ch )) {
				tk = HTMLLexemes::TEXT;
				if (outTokens) {
					outTokens->push_back( new HTMLLexerToken( ILexerToken::TT_HTML_ENTITY, nStartingPosition, entity.GetLength(), entity, ch ) );
				}
				return tk;
			}
		} break;
		case CHAR_EQUALS_SIGN: {
			tokenStr.AppendUniChar( fLexerInput->MoveToNextChar() );
			tk = (int)inChar;
		} break;
		case CHAR_SOLIDUS: {
			fLexerInput->MoveToNextChar();
			if (fLexerInput->HasMoreChars()) {
				if (fLexerInput->PeekAtNextChar() == CHAR_GREATER_THAN_SIGN) {
					tk = HTMLLexemes::SELF_CLOSE;
					tokenStr = "/>";
					fLexerInput->MoveToNextChar();	// Eat the >
				}
			}
			if (!tk)	fLexerInput->MoveToPreviousChar();
		} break;
		case CHAR_LESS_THAN_SIGN: {
			tokenStr.AppendUniChar( fLexerInput->MoveToNextChar() );
			tk = (int)inChar;
			if (fLexerInput->HasMoreChars()) {
				if (fLexerInput->PeekAtNextChar() == CHAR_SOLIDUS) {
					tk = HTMLLexemes::START_OF_CLOSE_TAG;
					tokenStr = "</";
					fLexerInput->MoveToNextChar();	// Eat the /
				} else if (fLexerInput->PeekAtNextChar() == CHAR_EXCLAMATION_MARK) {
					tk = HTMLLexemes::BANG_START;
					tokenStr = "<!";
					fLexerInput->MoveToNextChar();
				} else if (fLexerInput->PeekAtNextChar() == CHAR_QUESTION_MARK) {
					tk = HTMLLexemes::QUESTION_START;
					tokenStr = "<?";
					fLexerInput->MoveToNextChar();
				}
			} 
		} break;
		case CHAR_GREATER_THAN_SIGN: {
			tokenStr.AppendUniChar( fLexerInput->MoveToNextChar() );
			tk = (int)inChar;
		} break;
	}

	if (tk && outTokens) {
		outTokens->push_back( new HTMLLexerToken( ILexerToken::TT_PUNCTUATION, 
									nStartingPosition, tokenStr.GetLength(), tokenStr, tk ) );
	}
	return tk;
}

bool HTMLLexer::AdvanceOneToken( int &outToken, TokenList *outTokens )
{
	outToken = -1;

	if (!fLexerInput)
		return false;

	// There can be any combination of newlines and whitespaces preceeding semantic tokens,
	// so we're going to loop until we don't find either.
	while (fLexerInput->HasMoreChars())
	{
		bool consumedWhitespace = false;
		bool consumedNewLine = false;
		if (!SkipWhitespaces( consumedWhitespace, outTokens ))
			return false;

		// HTML also treats newlines as a whitespace
		while (fLexerInput->HasMoreChars() && IsLineEnding( fLexerInput->PeekAtNextChar() ))
		{
			// Eat the line ending
			ConsumeLineEnding( fLexerInput->MoveToNextChar() );
			consumedNewLine = true;
		}

		// If we're done consuming newlines and whitespaces, then we're done with this loop
		if (!consumedWhitespace && !consumedNewLine)
			break;
	}
	if (!fLexerInput->HasMoreChars())
		return false;

	// Take a peek at what sort of token we're about to deal with. 
	UniChar	uChar = fLexerInput->PeekAtNextChar();
	sLONG stringType;
	sLONG stringValue;

	if( (outToken = ConsumePossiblePunctuation(uChar, outTokens)) != 0 )
	{
	}
	else if (IsStringStart( uChar, stringType, stringValue ))
	{
		VString	vstrQuoted;
		if (!ConsumeString( &vstrQuoted, outTokens, stringType, stringValue ))
		{
			return false;
		}
		outToken = stringValue;
		fLastTokenText = vstrQuoted;
	}
	else if (IsIdentifierStart( uChar ))
	{
		// The base class assumes we've consumed the first character already for this call.  We should
		// rectify this some day, as it's very confusing.
		fLexerInput->MoveToNextChar();
		VString *vstrNAME = ConsumeIdentifier();
		if (!vstrNAME)
		{
			return false;
		}

		outToken = HTMLLexemes::TEXT;
		if (outTokens)	outTokens->push_back( new HTMLLexerToken( ILexerToken::TT_NAME, fLexerInput->GetCurrentPosition() - vstrNAME->GetLength(), vstrNAME->GetLength(), *vstrNAME, outToken ) );

		fLastTokenText = *vstrNAME;
		delete vstrNAME;
	}
	else
	{
		return false;
	}
	
	SetLastToken( outToken );
	return true;
}

int HTMLLexer::PeekAtNextTokenForParser()
{
	// If we've already peeked, then just return the peeked token
	if (fPeeked)	return fLastToken;

	// Otherwise, get the next token (which is assigned to fLastToken
	// automatically), and set our peeked flag
	int ret = GetNextTokenForParser();
	fPeeked = true;
	return ret;
}

int HTMLLexer::GetNextTokenForParser()
{
	// If we peeked at a token, then just return the last one we got
	if (fPeeked) {
		int ret = fLastToken;
		fPeeked = false;	// We're no longer in peek mode though!
		return ret;
	}

	// Otherwise, get the next token in the stream
	int token;
	if (AdvanceOneToken( token, NULL ))	return token;
	return -1;
}

VError HTMLLexer::Tokenize( TokenList &outTokens, bool inContinuationOfComment, sLONG inOpenStringType )
{
	fCommentContinuationMode = inContinuationOfComment;

	int	nToken = 0;
	while (AdvanceOneToken( nToken, &outTokens ))
		;	// Infinite loop!

	return VE_OK;
}

void HTMLLexer::SetLexerInput( VString *inInput )
{
	VLexerStringInput *lexerInput = new VLexerStringInput();
	lexerInput->Init( inInput );
	SetLexerInput( lexerInput );
}
